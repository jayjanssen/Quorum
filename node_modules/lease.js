// Copyright (c) 2011 Yahoo! Inc. All rights reserved. Licensed under the BSD
// License. See accompanying LICENSE file or
// http://www.opensource.org/licenses/BSD-3-Clause for the specific language
// governing permissions and limitations under the
// License.


// A quorum lease interacts with the storage layer
var log = require( 'logger' )( 'Lease', 'WARN');
var util = require( 'util' );
var dns = require( 'dns' );
var async = require( 'async' );
var jsonxml = require( 'jsonxml' );
var qs = require("./storage");

var QuorumLease = function( key ) {
  var k = key;
  k.replace( /\/$/, ''); // strip ending slash
  
  var lease_key = k;
  
  var that = {};

  // local cache of the lease.  This object is responsible for 
  // maintaining it.
  var lease_cache = (function() {    
    var local_copy; 
    var local_OBJ;
    var initialized = false;
    var me = {};
  
    me.set = function( new_copy ) {
      initialized = true;
      local_copy = new_copy;
    };
    me.get = function() {
      return local_copy;
    };
    
    me.set_OBJ = function( new_OBJ ) {
      local_OBJ = new_OBJ;
    }
    me.get_OBJ = function() {
      return local_OBJ;
    }
    
    me.clear = function() {
      initialized = false;
      local_copy = undefined;
      local_OBJ = undefined;
    };
    me.is_initialized = function() {
      return initialized;
    };
    
    return me;
  }());
  

  // Get the current unix time
  var get_unixtime = function() {
    var date = new Date();
    return parseInt( date.getTime() / 1000, 10 );
  };
  
  // Convert a unixtime back into a usable string
  var format_unixtime = function( unixtime ) {
    var date = new Date( unixtime * 1000 );
    return date.toUTCString();    
  };
  
  // Format seconds into a cleaner duration
  var format_seconds = function( seconds ) {
    if( seconds < 0 ) {
      return seconds;      
    }
    
    var output = [];
    var remainder;
    
    var days = Math.floor( seconds / 86400 );
    var remainder = seconds % 86400;
    if( days >= 1 ) {
      output.push( days + 'd' );
    }
    
    var hours = Math.floor( remainder / 3600 );
    remainder = remainder % 3600;
    if( hours >= 1 ) {
      output.push( hours + 'h' );
    }
    
    var minutes = Math.floor( remainder / 60 );
    remainder = remainder % 60;
    if( minutes >= 1 ) {
      output.push( minutes + 'm' );
    }
    
    if( remainder >= 1 ) {
      output.push( remainder + "s" );
    }

    return output.join( ' ' );
    
  }
  
  // If the owner is an IP (v4 for now), do a reverse lookup on it and
  // pass that to cb.  Otherwise pass the owner string unmodified.
  var lookup_owner = function( owner, cb ) {
    if( /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test( owner )) {
      dns.reverse( owner, function( err, domains ) {
        if( !err ) {
          cb( domains.toString() );
        } else {
          log.warn( "Can't reverse DNS: " + owner + ": " + err );
          cb( owner );
        }
      });
    } else {
      cb( owner );
    }
  };
  
    
  // Get the lease object from storage
  // Args: cb( lease, version )
  // Meta will be either:
  // - undefined: storage error
  // - false: doesn't exist or doesn't parse
  // - the lease object (JSON-parsed)
  // - version: the version of the lease
  var storage_get = function( cb ) {
    qs.get( lease_key, function( json, version ) {
      if( json === undefined || json === false ) { 
        // value is falsey, pass it up the chain
        cb( json );
        return;
      } else {
        // Parse the JSON
        try {
          var lease = JSON.parse( json );
          lease.storage_version = version; // version is separate in the storage
          if( lease === undefined ) { // bad parse
            cb( false );
          } else {
            cb( lease, version );
          }                      
        } catch( e ) {
          cb( false ); // doesn't parse
        }
      }
    });
  };
  
  // Get the lease object from storage, use local cache if it's valid
  // Same as above
  var get = function( cb ) {
    if( !lease_cache.is_initialized() ) {
      storage_get( function( lease ) {
        lease_cache.set( lease );
        cb( lease_cache.get() );
      });      
    } else {
      cb( lease_cache.get() );      
    }
  };
  
  // Functions that manipulate the JSON lease object for various
  // operations.
  var init_lease_json = function( oldlease, owner, ttl, object ) {
    var lease = {};
    lease.type = 'lease';
    lease.owner = owner;
    lease.ttl = ttl;
    lease.acquired = get_unixtime();
    lease.renewed = lease.acquired;
    lease.expires = lease.acquired + parseInt( ttl, 10 );
    lease.renewals = 0;
    lease.released = false;
    lease.client_object = object;
    
    lease.history = []; // start a new history array
    if( oldlease !== null && oldlease.history !== undefined ) {      
      lease.history = oldlease.history;      
    }
    
    if( oldlease !== null ) {
      // harvest oldlease for history
      var historical = JSON.parse( JSON.stringify( oldlease ));
      delete historical.history;
      lease.history.unshift( historical ); // stick the old lease on the history stack      
      lease.history = lease.history.slice( 0, 10 ); // keep 10 history items
    }
    log.trace( "Object: " + util.inspect( lease ));
    return JSON.stringify( lease );
  };  
  var renew_lease_json = function( lease, object ) {
    // update the expires value
    lease.renewed = get_unixtime();
    lease.expires = get_unixtime() + parseInt( lease.ttl, 10 );
    lease.client_object = object;
    lease.released = false;
    lease.renewals += 1;
    
    return JSON.stringify( lease );
  };  
  var release_lease_json = function( lease ) {
    // update the expires value
    lease.released = get_unixtime();
    
    return JSON.stringify( lease );
  };
  
  // Public Methods
  
  // Accessor for k (no mutator)
  that.key = function() {
    return k;
  };
  
  // Generate a set of accessor functions that will pull a lease from storage 
  // and get a specific attribute
  var method_generator = function() {
    var sample_lease = JSON.parse( init_lease_json( null, '', '', '' ));
    var name;
    
    // helper method so the variable bindings don't get screwed up
    var create_method = function( name ) {
      return function( cb ) {
        get( function( lease ) {
          if( !lease ) {
            cb( lease );
          } else {
            cb( lease[name] );
          }
        });
      };
    };

    for( name in sample_lease ) {
      if( sample_lease.hasOwnProperty( name )) {
        var method_name = 'get_' + name;
        that[method_name] = create_method( name );
      }
    }
  };
  method_generator();
  
  // Check if this node is actually a lease
  // Args: cb( answer )
  // answer can be:
  // - true - it's a lease
  // - false - not a lease
  // - undefined - storage error
  that.is_lease = function( cb ) {
    get( function( lease ) {
      if( !lease ) { 
        cb( lease );
      } else {
        cb( lease.type === 'lease' );
      }     
    });
  };  
  

  // Check if owner matches.
  // Args: cb( answer )
  // answer can be:
  // - true - the owner matches
  // - false - the owner does not match
  // - undefined - storage error  
  that.is_owner = function( potential_owner, cb ) {    
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else if( lease.owner !== potential_owner ) { 
        cb( false );
      } else {
        that.is_valid( cb );
      }     
    });
  };
  
  // Check if the lease is valid
  // Args: cb( answer )
  // answer can be:
  // - true - the lease is valid
  // - false - the lease is not valid
  // - undefined - storage error
  that.is_valid = function( cb ) {
    get( function( lease ) {
      if( !lease ) { 
        cb( lease );
      } else if( lease.released || lease.expires < get_unixtime() ) { 
        // lease has been released or has expired
        cb( false );
      } else {
        cb( true );
      }     
    });
  };
  
  // Get the lease version if it exists in storage
  // cb( version )
  // version === false if it doesn't exist in the system
  that.get_version = function( cb ) {
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else {
        cb( lease.storage_version );
      }
    });
  };
  
  
  // Acquire the lease (must be new or invalid)
  // Args: owner, ttl, object, version, cb( newversion )
  // owner - the new lease owner
  // ttl - the time for the lease to remain valid
  // object - the lease object
  // version - if the lease already exists (and has been checked to be invalid)
  //    otherise null
  // newversion - results of the operation
  //    newversion can be:
  //    - value: lease version # (success)
  //    - false: action failed (lease already owned or version mismatch)
  //    - undefined: storage error
  that.acquire = function( owner, ttl, object, version, callback ) {
    log.debug( "Aquire: " + version );
    get( function( lease ) {
      var lease_str;
      if( lease === undefined ) {
        callback( lease );
      } else if( lease === false ) {
        // Try create
        lease_str = init_lease_json( null, owner, ttl, object );
        qs.create( lease_key, lease_str, function( lease_json, version ) {
          lease_cache.clear();
          if( !lease_json ) {
            callback( lease_json ); // pass errors up
          } else {
            callback( version );
          }
        });  
      } else {
        // Update the lease data
        lease_str = init_lease_json( lease, owner, ttl, object );  
        lease_cache.clear();
        qs.update( lease_key, lease_str, version, callback );
      }
    });
  };
  
  // Renew the lease (must already have been acquired)
  // Args: version, object, cb( result )
  // version - the version to renew
  // object - the lease object
  // result - results of the operation
  //    result can be:
  //    - value: lease version # (success)
  //    - false: action failed (lease already owned)
  //    - undefined: storage error
  that.renew = function( version, object, cb ) {
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else {
        var lease_str = renew_lease_json( lease, object );
        lease_cache.clear();
        qs.update( lease_key, lease_str, version, cb );
      }
    });
  };
  
  // Release the lease
  // Args: version, cb( result )
  // version - the version of the lease to release
  // result - results of the operation
  //    result can be:
  //    - value: version of the released lease
  //    - false: action failed (version mismatch)
  //    - undefined: storage error
  that.release = function( version, cb ) {
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else {
        var lease_str = release_lease_json( lease );
        lease_cache.clear();
        qs.update( lease_key, lease_str, version, cb );
      }
    });
    
  };
  
  

  // Gets polished lease attributes by calling all the lease accessors
  // For use by getXXX functions in lease 'views'.
  var getOBJ = function( returnOBJ ) {
    async.parallel({
      is_valid: function( cb ) { that.is_valid( function( val ) { cb( null, val ); }); },
      owner: function( cb ) { that.get_owner( function( val ) { cb( null, val ); }); },
      ttl: function( cb ) { that.get_ttl( function( val ) { cb( null, val ); }); },
      acquired: function( cb ) { that.get_acquired( function( val ) { cb( null, val ); }); },
      renewed: function( cb ) { that.get_renewed( function( val ) { cb( null, val ); }); },
      expires: function( cb ) { that.get_expires( function( val ) { cb( null, val ); }); },
      renewals: function( cb ) { that.get_renewals( function( val ) { cb( null, val ); }); },
      released: function( cb ) { that.get_released( function( val ) { cb( null, val ); }); },    
      version: function( cb ) { that.get_version( function( val ) { cb( null, val ); }); }, 
      client_object: function( cb ) { that.get_client_object( function( val ) { cb( null, val ); }); },    
   
      history: function( cb ) { 
        that.get_history( function( history ) { 
          async.forEach( history, function( oldlease, callback ) {
            lookup_owner( oldlease.owner, function( name ) {
              oldlease.owner_name = name;
              callback( null );
            });
          }, function( err ) {
            cb( null, history ); 
          });
        });
      },
      
      owner_name: function( cb ) {        
        that.get_owner( function( owner ) {
          lookup_owner( owner, function( result ) {
            cb( null, result );
          });
        });
      }
    },
    function( err, results ) {
      results.key = that.key();
      returnOBJ( results );
    });
  };
  
  // do a getOBJ and store it in the lease_cache
  // required call before to* functions
  // cb called with a obj parameter when done
  that.fetch = function( cb ) {
    getOBJ( function( obj ) { 
      lease_cache.set_OBJ( obj ); 
      cb( obj )
    });
  }
  
  // Gets a JSON representation of the lease (non-blocking, guaranteed)
  that.toJSON = function() {
    var obj = lease_cache.get_OBJ();
    if( obj === undefined ) {
      return undefined;
    }
    return obj;      
  };
  
  // Gets a plaintext formatted output of the lease (non-blocking, guaranteed)
  that.toString = function( obj ) {
    var obj = lease_cache.get_OBJ();
    if( obj === undefined ) {
      return undefined;
    }
    
    var result = "Lease: " + lease_key + "\n";
    
    if( obj.is_valid ) {
      result += "  Lease is VALID\n";
    } else {
      result += "  Lease is INVALID\n";
    }
    
    result += "  Owner: " + obj.owner_name + " (" + obj.owner + ")\n";
    result += "  TTL: " + format_seconds( obj.ttl ) + "s\n";
    
    result += "  Acquired: " + format_unixtime( obj.acquired ) + "\n";
    
    result += "  Renewed: " + format_unixtime( obj.renewed ) + "\n";
    
    if( obj.is_valid ) {
      result += "  Expires: " + format_unixtime( obj.expires ) + "\n";
              
      var diff = get_unixtime() - obj.acquired;
      result += "  Time Held: " +  format_seconds( diff ) + "\n";
    } else {      
      var diff;
      if( obj.released ) {
        result += "  Released: " + format_unixtime( obj.released ) + "\n";        
        diff = obj.released - obj.acquired;
      } else {
        result += "  Expired: " + format_unixtime( obj.expires ) + "\n";
        diff = obj.expires - obj.acquired;
      }
      result += "  Time Held: " +  format_seconds( diff ) + "\n";

    }
    result += "  Renewals: " + obj.renewals + "\n";
    result += "  Version: " + obj.version + "\n";
    
    result += "  Client Object: " + obj.client_object + "\n";
  
    result += "  History: " + "\n";
  
    var index;
    for( index in obj.history ) {
      if( obj.history.hasOwnProperty( index )) {          
        var old_lease = obj.history[index];
    
    
        log.debug( "Acquired: " + old_lease.acquired );
        log.debug( "Expires: " + old_lease.expires );
        log.debug( "Released: " + old_lease.released );

        var diff = old_lease.expires - old_lease.acquired;
        if( old_lease.released > 0 ) {
          diff = old_lease.released - old_lease.acquired;
        }
        result += "    " + old_lease.owner_name + " started " + format_unixtime( old_lease.acquired );
        
        if( old_lease.released > 0 ) {
          result += " released after ";
        } else {
          result += " expired after ";
        }
        
        result += format_seconds( diff ) + "\n";
      }
    }
   
    return result;
  };
  
  that.toXML = function() {
    var obj = lease_cache.get_OBJ();
    if( obj === undefined ) {
      return undefined;
    }
    
    // modify the lease history so it transforms well into xml
    for( index in obj.history ) {
      if( obj.history.hasOwnProperty( index )) {
        var oldlease = obj.history[index];
        
        obj.history[index] = { name: 'oldlease', children: oldlease };
      }
    }
    
    return "<lease>" + jsonxml.obj_to_xml( obj ) + "</lease>";
    
  };
  
  // Gets a HTML formatted output of the lease suitable for a <div> tag (non-blocking, guaranteed)
  that.toHTML = function() {
    var obj = lease_cache.get_OBJ();
    if( obj === undefined ) {
      return undefined;
    }
    
    var result = "<h2>" + lease_key + "</h2>";
    result += "<table>"
    
    result += "<tr><th>Status</th><td>";
    if( obj.is_valid ) {
      result += "VALID";
    } else {
      result += "INVALID";
    }
    result += "</td></tr>\n";
    
    result += "<tr><th>Owner</th><td>" + obj.owner_name + " (" + obj.owner + ")</td></tr>\n";
    result += "<tr><th>TTL</th><td>" + format_seconds( obj.ttl ) + "</td></tr>\n";
    
    result += "<tr><th>Acquired</th><td>" + format_unixtime( obj.acquired ) + "</td></tr>\n";
    
    result += "<tr><th>Renewed</th><td>" + format_unixtime( obj.renewed ) + "</td></tr>\n";
    
    if( obj.is_valid ) {
      result += "<tr><th>Expires</th><td>" + format_unixtime( obj.expires ) + "</td></tr>\n";
              
      var diff = get_unixtime() - obj.acquired;
      result += "<tr><th>Time Held</th><td>" +  format_seconds( diff ) + "</td></tr>\n";
    } else {      
      var diff;
      if( obj.released ) {
        result += "<tr><th>Released</th><td>" + format_unixtime( obj.released ) + "</td></tr>\n";        
        diff = obj.released - obj.acquired;
      } else {
        result += "<tr><th>Expired</th><td>" + format_unixtime( obj.expires ) + "</td></tr>\n";
        diff = obj.expires - obj.acquired;
      }
      result += "<tr><th>Time Held</th><td>" +  format_seconds( diff ) + "</td></tr>\n";

    }
    result += "<tr><th>Renewals</th><td>" + obj.renewals + "</td></tr>\n";
    result += "<tr><th>Version</th><td>" + obj.version + "</td></tr>\n";
    
    result += "<tr><th>Client Object</th><td>" + obj.client_object + "</td></tr>\n";
  
    result += "<tr><th>History</th><td>";
  
    var index;
    for( index in obj.history ) {
      if( obj.history.hasOwnProperty( index )) {          
        var old_lease = obj.history[index];
    
    
        log.debug( "Acquired: " + old_lease.acquired );
        log.debug( "Expires: " + old_lease.expires );
        log.debug( "Released: " + old_lease.released );

        var diff = old_lease.expires - old_lease.acquired;
        if( old_lease.released > 0 ) {
          diff = old_lease.released - old_lease.acquired;
        }
        result += "" + old_lease.owner_name + " started " + format_unixtime( old_lease.acquired );
        
        if( old_lease.released > 0 ) {
          result += " released after ";
        } else {
          result += " expired after ";
        }
        
        result += format_seconds( diff ) + "<br>\n";
      }
    }
    result += "</td></tr>\n";
    result += "</table>\n";
    return result;
  };
  
  // return a table row with a lease summary
  that.toHTMLRow = function() {
    var obj = lease_cache.get_OBJ();
    if( obj === undefined ) {
      return undefined;
    }
    
    var result = '';
    result += "<tr><td><a href='" + obj.key + "'>" + obj.key + '</a></td>';
    result += '<td>' + obj.is_valid + '</td>'; 
    result += '<td>' + obj.owner_name + '</td>'; 
    result += '</tr>';    
    
    return result;
  }
  
  
  // Get an array of HTTP headers
  that.toHTTPHeaders = function( callback ) {
    var obj = lease_cache.get_OBJ();
    if( obj === undefined ) {
      return undefined;
    }
    
    var headers = {      
      'X-Quorum-Client-ID' : obj.owner,      
      'X-Quorum-Lease-Length' : obj.ttl,
      'X-Quorum-Lease-Acquired' : obj.acquired,
      'X-Quorum-Lease-Expires' : obj.expires,
      'X-Quorum-Lease-Renewed' : obj.renewed,
      'X-Quorum-Lease-Renewals' : obj.renewals,
      'X-Quorum-Lease-Version' : obj.version
    };
      
    // Convert headers false to empty strings
    var name;
    for( name in headers ) {
      if( headers.hasOwnProperty( name )) {
        if( headers[name] === false ) {
          headers[name] = '';
        }
      }
    }
    log.trace( "Headers: " + util.inspect( headers ));
      
    return headers;
  };
  
 

  // Shutdown the QS manually as needed
  that.close = function() { qs.close(); };
  
  return that;
};

module.exports = QuorumLease;