// Copyright (c) 2011 Yahoo! Inc. All rights reserved. Licensed under the BSD
// License. See accompanying LICENSE file or
// http://www.opensource.org/licenses/BSD-3-Clause for the specific language
// governing permissions and limitations under the
// License.


// A quorum lease interacts with the storage layer
var log = require( 'logger' )( 'Lease', 'WARN');
var util = require( 'util' );
var dns = require( 'dns' );
var async = require( 'async' );
var qs = require("./storage");

var QuorumLease = function( key ) {
  var k = key;
  k.replace( /\/$/, ''); // strip ending slash
  
  // Lease is not stored at the actual key in case of other
  // children, but as a subkey. This way the lease object can
  // freely be deleted and recreated.
  var lease_key = k;
  
  var that = {};

  // local cache of the lease.  This object is responsible for 
  // maintaining it.
  var lease_cache = (function() {    
    var local_copy; 
    var initialized = false;
    var me = {};
  
    me.set = function( new_copy ) {
      initialized = true;
      local_copy = new_copy;
    };
    me.clear = function() {
      initialized = false;
      local_copy = undefined;
    };
    me.get = function() {
      return local_copy;
    };
    me.is_initialized = function() {
      return initialized;
    };
    
    return me;
  }());

  // Get the current unix time
  var get_unixtime = function() {
    var date = new Date();
    return parseInt( date.getTime() / 1000, 10 );
  };
  
  // Convert a unixtime back into a usable string
  var format_unixtime = function( unixtime ) {
    var date = new Date( unixtime * 1000 );
    return date.toUTCString();    
  };
  
  // If the owner is an IP (v4 for now), do a reverse lookup on it and
  // pass that to cb.  Otherwise pass the owner string unmodified.
  var lookup_owner = function( owner, cb ) {
    if( /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test( owner )) {
      dns.reverse( owner, function( err, domains ) {
        if( !err ) {
          cb( domains.toString() );
        } else {
          log.warn( "Can't reverse DNS: " + owner + ": " + err );
          cb( owner );
        }
      });
    } else {
      cb( owner );
    }
  };
  
    
  // Get the lease object from storage
  // Args: cb( lease, version )
  // Meta will be either:
  // - undefined: storage error
  // - false: doesn't exist or doesn't parse
  // - the lease object (JSON-parsed)
  // - version: the version of the lease
  var storage_get = function( cb ) {
    qs.get( lease_key, function( json, version ) {
      if( json === undefined || json === false ) { 
        // value is falsey, pass it up the chain
        cb( json );
        return;
      } else {
        // Parse the JSON
        try {
          var lease = JSON.parse( json );
          lease.storage_version = version; // version is separate in the storage
          if( lease === undefined ) { // bad parse
            cb( false );
          } else {
            cb( lease, version );
          }                      
        } catch( e ) {
          cb( false ); // doesn't parse
        }
      }
    });
  };
  
  // Get the lease object from storage, use local cache if it's valid
  // Same as above
  var get = function( cb ) {
    if( !lease_cache.is_initialized() ) {
      storage_get( function( lease ) {
        lease_cache.set( lease );
        cb( lease_cache.get() );
      });      
    } else {
      cb( lease_cache.get() );      
    }
  };
  
  // Functions that manipulate the JSON lease object for various
  // operations.
  var init_lease_json = function( oldlease, owner, ttl, object ) {
    var lease = {};
    lease.type = 'lease';
    lease.owner = owner;
    lease.ttl = ttl;
    lease.acquired = get_unixtime();
    lease.renewed = lease.acquired;
    lease.expires = lease.acquired + parseInt( ttl, 10 );
    lease.renewals = 0;
    lease.released = false;
    lease.client_object = object;
    
    lease.history = []; // start a new history array
    if( oldlease !== null && oldlease.history !== undefined ) {      
      lease.history = oldlease.history;      
    }
    
    if( oldlease !== null ) {
      // harvest oldlease for history
      var historical = JSON.parse( JSON.stringify( oldlease ));
      delete historical.history;
      lease.history.unshift( historical ); // stick the old lease on the history stack      
      lease.history = lease.history.slice( 0, 10 ); // keep 10 history items
    }
    log.trace( "Object: " + util.inspect( lease ));
    return JSON.stringify( lease );
  };  
  var renew_lease_json = function( lease, object ) {
    // update the expires value
    lease.renewed = get_unixtime();
    lease.expires = get_unixtime() + parseInt( lease.ttl, 10 );
    lease.client_object = object;
    lease.released = false;
    lease.renewals += 1;
    
    return JSON.stringify( lease );
  };  
  var release_lease_json = function( lease ) {
    // update the expires value
    lease.released = get_unixtime();
    
    return JSON.stringify( lease );
  };
  
  // Public Methods
  
  // Accessor for k (no mutator)
  that.key = function() {
    return k;
  };
  
  // Generate a set of accessor functions that will pull a lease from storage 
  // and get a specific attribute
  var method_generator = function() {
    var sample_lease = JSON.parse( init_lease_json( null, '', '', '' ));
    var name;
    
    // helper method so the variable bindings don't get screwed up
    var create_method = function( name ) {
      return function( cb ) {
        get( function( lease ) {
          if( !lease ) {
            cb( lease );
          } else {
            cb( lease[name] );
          }
        });
      };
    };

    for( name in sample_lease ) {
      if( sample_lease.hasOwnProperty( name )) {
        var method_name = 'get_' + name;
        that[method_name] = create_method( name );
      }
    }
  };
  method_generator();
  
  // Check if this node is actually a lease
  // Args: cb( answer )
  // answer can be:
  // - true - it's a lease
  // - false - not a lease
  // - undefined - storage error
  that.is_lease = function( cb ) {
    get( function( lease ) {
      if( !lease ) { 
        cb( lease );
      } else {
        cb( lease.type === 'lease' );
      }     
    });
  };  
  

  // Check if owner matches.
  // Args: cb( answer )
  // answer can be:
  // - true - the owner matches
  // - false - the owner does not match
  // - undefined - storage error  
  that.is_owner = function( potential_owner, cb ) {    
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else if( lease.owner !== potential_owner ) { 
        cb( false );
      } else {
        that.is_valid( cb );
      }     
    });
  };
  
  // Check if the lease is valid
  // Args: cb( answer )
  // answer can be:
  // - true - the lease is valid
  // - false - the lease is not valid
  // - undefined - storage error
  that.is_valid = function( cb ) {
    get( function( lease ) {
      if( !lease ) { 
        cb( lease );
      } else if( lease.released || lease.expires < get_unixtime() ) { 
        // lease has been released or has expired
        cb( false );
      } else {
        cb( true );
      }     
    });
  };
  
  // Get the lease version if it exists in storage
  // cb( version )
  // version === false if it doesn't exist in the system
  that.get_version = function( cb ) {
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else {
        cb( lease.storage_version );
      }
    });
  };
  
  
  // Acquire the lease (must be new or invalid)
  // Args: owner, ttl, object, version, cb( newversion )
  // owner - the new lease owner
  // ttl - the time for the lease to remain valid
  // object - the lease object
  // version - if the lease already exists (and has been checked to be invalid)
  //    otherise null
  // newversion - results of the operation
  //    newversion can be:
  //    - value: lease version # (success)
  //    - false: action failed (lease already owned or version mismatch)
  //    - undefined: storage error
  that.acquire = function( owner, ttl, object, version, callback ) {
    log.debug( "Aquire: " + version );
    get( function( lease ) {
      var lease_str;
      if( lease === undefined ) {
        callback( lease );
      } else if( lease === false ) {
        // Try create
        lease_str = init_lease_json( null, owner, ttl, object );
        qs.create( lease_key, lease_str, function( lease_json, version ) {
          lease_cache.clear();
          if( !lease_json ) {
            callback( lease_json ); // pass errors up
          } else {
            callback( version );
          }
        });  
      } else {
        // Update the lease data
        lease_str = init_lease_json( lease, owner, ttl, object );  
        lease_cache.clear();
        qs.update( lease_key, lease_str, version, callback );
      }
    });
  };
  
  // Renew the lease (must already have been acquired)
  // Args: version, object, cb( result )
  // version - the version to renew
  // object - the lease object
  // result - results of the operation
  //    result can be:
  //    - value: lease version # (success)
  //    - false: action failed (lease already owned)
  //    - undefined: storage error
  that.renew = function( version, object, cb ) {
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else {
        var lease_str = renew_lease_json( lease, object );
        lease_cache.clear();
        qs.update( lease_key, lease_str, version, cb );
      }
    });
  };
  
  // Release the lease
  // Args: version, cb( result )
  // version - the version of the lease to release
  // result - results of the operation
  //    result can be:
  //    - value: version of the released lease
  //    - false: action failed (version mismatch)
  //    - undefined: storage error
  that.release = function( version, cb ) {
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else {
        var lease_str = release_lease_json( lease );
        lease_cache.clear();
        qs.update( lease_key, lease_str, version, cb );
      }
    });
    
  };
  
  
  // // Load this lease from the data store
  // //  cb is called when the lease is loaded
  // // - true: lease is loaded
  // // - false: lease is not loaded or doesn't exist
  // that.load = function( cb ) {
  //   get( function( lease ) {
  //     if( !lease ) {
  //       cb( false );
  //     } else {
  //       cb( true );
  //     }
  //   });
  // };
  // 
  // Get an array of HTTP headers
  that.getHTTPHeaders = function( callback ) {
    async.parallel({
      'X-Quorum-Client-ID' : function( cb ) {
        that.get_owner( function( value ) { cb( null, value ); });
      },
      'X-Quorum-Lease-Length' : function( cb ) {
        that.get_ttl( function( value ) { cb( null, value ); });
      },
      'X-Quorum-Lease-Acquired' : function( cb ) {
        that.get_acquired( function( value ) { cb( null, value ); });
      },
      'X-Quorum-Lease-Expires' : function( cb ) {
        that.get_expires( function( value ) { cb( null, value ); });
      },          
      'X-Quorum-Lease-Renewed' : function( cb ) {
        that.get_renewed( function( value ) { cb( null, value ); });
      },      
      'X-Quorum-Lease-Renewals' : function( cb ) {
        that.get_renewals( function( value ) { cb( null, value ); });
      },      
      'X-Quorum-Lease-Version' : function( cb ) {
        that.get_version( function( value ) { cb( null, value ); });
      }      
    }, function( err, headers ) {      
      if( err ) {
        callback( undefined );
        return;
      }
      
      // Convert headers false to empty strings
      var name;
      for( name in headers ) {
        if( headers.hasOwnProperty( name )) {
          if( headers[name] === false ) {
            headers[name] = '';
          }
        }
      }

      log.trace( "Headers: " + util.inspect( headers ));
      
      callback( headers );
    });        
  };
  
  // Gets polished lease attributes by calling all the lease accessors
  // For use by getXXX functions in lease 'views'.
  var getOBJ = function( cb ) {
    async.parallel({
      is_valid: function( cb ) { that.is_valid( function( val ) { cb( null, val ); }); },
      ttl: function( cb ) { that.get_ttl( function( val ) { cb( null, val ); }); },
      acquired: function( cb ) { that.get_acquired( function( val ) { cb( null, val ); }); },
      renewed: function( cb ) { that.get_renewed( function( val ) { cb( null, val ); }); },
      expires: function( cb ) { that.get_expires( function( val ) { cb( null, val ); }); },
      renewals: function( cb ) { that.get_renewals( function( val ) { cb( null, val ); }); },
      released: function( cb ) { that.get_released( function( val ) { cb( null, val ); }); },    
      version: function( cb ) { that.get_version( function( val ) { cb( null, val ); }); },    
      history: function( cb ) { 
        that.get_history( function( history ) { 
          async.forEach( history, function( oldlease, callback ) {
            lookup_owner( oldlease.owner, function( owner ) {
              oldlease.owner = owner;
              callback( null );
            });
          }, function( err ) {
            cb( null, history ); 
          });
        });
      },
      owner: function( cb ) {        
        that.get_owner( function( owner ) {
          lookup_owner( owner, function( result ) {
            cb( null, result );
          });
        });
      }
    },
    function( err, results ) {
      cb( results );
    });
  };
  
  // Gets a JSON representation of the lease (non-blocking, guaranteed)
  that.getJSON = function( cb ) {
    getOBJ( function( results ) {      
      cb( JSON.stringify( results ));
    });      
  };
  
  // Gets a plaintext formatted output of the lease (non-blocking, guaranteed)
  that.getTXT = function( callback ) {
    getOBJ( function( results ) {      
      var result = "Lease: " + lease_key + "\n";
      
      if( results.is_valid ) {
        result += "  Lease is VALID\n";        
      } else {
        result += "  Lease is INVALID\n";
      }
      
      result += "  Owner: " + results.owner + "\n";
      
      result += "  Acquired: " + format_unixtime( results.acquired ) + "\n";
      
      result += "  TTL: " + results.ttl + "s\n";
      result += "  Renewed: " + format_unixtime( results.renewed ) + "\n";
      result += "  Renewals: " + results.renewals + "\n";
      
      if( results.is_valid ) {
        result += "  Expires: " + format_unixtime( results.expires ) + "\n";
      } else {      
        if( results.released ) {
          result += "  Released: " + format_unixtime( results.released ) + "\n";        
        } else {
          result += "  Expired: " + format_unixtime( results.expires ) + "\n";
        }
      }
      result += "  Version: " + results.version + "\n";
    
      result += "  History: " + "\n";
    
      var index;
      for( index in results.history ) {
        if( results.history.hasOwnProperty( index )) {          
          var old_lease = results.history[index];
      
      
          log.debug( "Acquired: " + old_lease.acquired );
          log.debug( "Expires: " + old_lease.expires );
          log.debug( "Released: " + old_lease.released );

          var diff = old_lease.expires - old_lease.acquired;
          if( old_lease.released > 0 ) {
            diff = old_lease.released - old_lease.acquired;
          }
          result += "    Started " + format_unixtime( old_lease.acquired ) + 
            " for " + diff + "s by " + old_lease.owner + "\n";
        }
      }
     
      callback( result );
    });
  };
  
  // Gets a HTML formatted output of the lease suitable for a <div> tag (non-blocking, guaranteed)
  that.getHTML = that.getTXT;
  
  // Return a string of the current lease state
  that.toString = function() {
    return util.inspect( lease_cache.get() );
  };
  
  that.toJSON = function() { 
    return JSON.stringify( lease_cache.get() );
  };

    
  // Shutdown the QS manually as needed
  that.close = function() { qs.close(); };
  
  return that;
};

module.exports = QuorumLease;