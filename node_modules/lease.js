// Copyright (c) 2011 Yahoo! Inc. All rights reserved. Licensed under the BSD
// License. See accompanying LICENSE file or
// http://www.opensource.org/licenses/BSD-3-Clause for the specific language
// governing permissions and limitations under the
// License.


// A quorum lease interacts with the storage layer
var log = require( 'logger' )( 'Lease', 'DEBUG');
var util = require( 'util' );
var async = require( 'async' );
var qs = require("./storage");

var QuorumLease = function( key ) {
  var k = key;
  k.replace( /\/$/, ''); // strip ending slash
  
  // Lease is not stored at the actual key in case of other
  // children, but as a subkey. This way the lease object can
  // freely be deleted and recreated.
  var lease_key = k;
  
  var that = {};

  // local cache of the lease.  This object is responsible for 
  // maintaining it.
  var lease_cache = (function() {    
    var local_copy; 
    var me = {};
  
    me.set = function( new_copy ) {
      local_copy = new_copy;      
    };
    me.clear = function() {
      local_copy = undefined;
    };
    me.get = function() {
      return local_copy;
    };
    
    return me;
  }());

  // Get the current unix time
  var get_unixtime = function() {
    var date = new Date();
    return parseInt( date.getTime() / 1000, 10 );
  };
  
  // Get the lease object from storage
  // Args: cb( lease, version )
  // Meta will be either:
  // - undefined: storage error
  // - false: doesn't exist or doesn't parse
  // - the lease object (JSON-parsed)
  // - version: the version of the lease
  var storage_get = function( cb ) {
    qs.get( lease_key, function( json, version ) {
      if( json === undefined || json === false ) { 
        // value is falsey, pass it up the chain
        cb( json );
        return;
      } else {
        // Parse the JSON
        try {
          var lease = JSON.parse( json );
          lease.storage_version = version; // version is separate in the storage
          if( lease === undefined ) { // bad parse
            cb( false );
          } else {
            cb( lease, version );
          }                      
        } catch( e ) {
          cb( false ); // doesn't parse
        }
      }
    });
  };
  
  // Get the lease object from storage, use local cache if it's valid
  // Same as above
  var get = function( cb ) {
    if( !lease_cache.get() ) {
      storage_get( function( lease ) {
        lease_cache.set( lease );
        cb( lease_cache.get() );
      });      
    } else {
      cb( lease_cache.get() );      
    }
  };
  
  // Functions that manipulate the JSON lease object for various
  // operations.
  var init_lease_json = function( lease, owner, ttl, object ) {
    var oldlease = lease;
    if( lease === null ) {
      lease = {};
    }
    lease.type = 'lease';
    lease.owner = owner;
    lease.ttl = ttl;
    lease.acquired = get_unixtime();
    lease.renewed = lease.acquired;
    lease.expires = lease.acquired + parseInt( ttl, 10 );
    lease.renewals = 0;
    lease.released = false;
    lease.client_object = object;

    if( lease.history === undefined ) {      
      lease.history = []; // start a new history array
    }
    if( oldlease !== null ) {
      // harvest oldlease for history
      var historical = JSON.parse( JSON.stringify( oldlease ));
      delete historical.history;
      lease.history.unshift( historical ); // stick the old lease on the history stack      
      lease.history = lease.history.slice( 0, 10 ); // keep 10 history items
    }
    log.trace( "Object: " + util.inspect( lease ));
    return JSON.stringify( lease );
  };  
  var renew_lease_json = function( lease, object ) {
    // update the expires value
    lease.renewed = get_unixtime();
    lease.expires = get_unixtime() + parseInt( lease.ttl, 10 );
    lease.client_object = object;
    lease.released = false;
    lease.renewals += 1;
    
    return JSON.stringify( lease );
  };  
  var release_lease_json = function( lease ) {
    // update the expires value
    lease.released = true;
    
    return JSON.stringify( lease );
  };
  
  // Public Methods
  
  // Accessor for k (no mutator)
  that.key = function() {
    return k;
  };
  
  // Generate a set of accessor functions that will pull a lease from storage 
  // and get a specific attribute
  var method_generator = function() {
    var sample_lease = JSON.parse( init_lease_json( null, '', '', '' ));
    var name;
    
    // helper method so the variable bindings don't get screwed up
    var create_method = function( name ) {
      return function( cb ) {
        get( function( lease ) {
          if( !lease ) {
            cb( lease );
          } else {
            cb( lease[name] );
          }
        });
      };
    };

    for( name in sample_lease ) {
      if( sample_lease.hasOwnProperty( name )) {
        var method_name = 'get_' + name;
        that[method_name] = create_method( name );
      }
    }
  };
  method_generator();
  
  // Check if this node is actually a lease
  // Args: cb( answer )
  // answer can be:
  // - true - it's a lease
  // - false - not a lease
  // - undefined - storage error
  that.is_lease = function( cb ) {
    get( function( lease ) {
      if( !lease ) { 
        cb( lease );
      } else {
        cb( lease.type === 'lease' );
      }     
    });
  };  
  

  // Check if owner matches.
  // Args: cb( answer )
  // answer can be:
  // - true - the owner matches
  // - false - the owner does not match
  // - undefined - storage error  
  that.is_owner = function( potential_owner, cb ) {    
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else if( lease.owner !== potential_owner ) { 
        cb( false );
      } else {
        that.is_valid( cb );
      }     
    });
  };
  
  // Check if the lease is valid
  // Args: cb( answer )
  // answer can be:
  // - true - the lease is valid
  // - false - the lease is not valid
  // - undefined - storage error
  that.is_valid = function( cb ) {
    get( function( lease ) {
      if( !lease ) { 
        cb( lease );
      } else if( lease.released || lease.expires < get_unixtime() ) { 
        // lease has been released or has expired
        cb( false );
      } else {
        cb( true );
      }     
    });
  };
  
  // Get the lease version if it exists in storage
  // cb( version )
  // version === false if it doesn't exist in the system
  that.get_version = function( cb ) {
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else {
        cb( lease.storage_version );
      }
    });
  };
  
  
  // Acquire the lease (must be new or invalid)
  // Args: owner, ttl, object, version, cb( newversion )
  // owner - the new lease owner
  // ttl - the time for the lease to remain valid
  // object - the lease object
  // version - if the lease already exists (and has been checked to be invalid)
  //    otherise null
  // newversion - results of the operation
  //    newversion can be:
  //    - value: lease version # (success)
  //    - false: action failed (lease already owned or version mismatch)
  //    - undefined: storage error
  that.acquire = function( owner, ttl, object, version, callback ) {
    log.debug( "Aquire: " + version );
    get( function( lease ) {
      var lease_str;
      if( lease === undefined ) {
        callback( lease );
      } else if( lease === false ) {
        // Try create
        lease_str = init_lease_json( null, owner, ttl, object );
        qs.create( lease_key, lease_str, function( lease_json, version ) {
          lease_cache.clear();
          if( !lease_json ) {
            callback( lease_json ); // pass errors up
          } else {
            callback( version );
          }
        });  
      } else {
        // Update the lease data
        lease_str = init_lease_json( lease, owner, ttl, object );  
        lease_cache.clear();
        qs.update( lease_key, lease_str, version, callback );
      }
    });
  };
  
  // Renew the lease (must already have been acquired)
  // Args: version, object, cb( result )
  // version - the version to renew
  // object - the lease object
  // result - results of the operation
  //    result can be:
  //    - value: lease version # (success)
  //    - false: action failed (lease already owned)
  //    - undefined: storage error
  that.renew = function( version, object, cb ) {
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else {
        var lease_str = renew_lease_json( lease, object );
        lease_cache.clear();
        qs.update( lease_key, lease_str, version, cb );
      }
    });
  };
  
  // Release the lease
  // Args: version, cb( result )
  // version - the version of the lease to release
  // result - results of the operation
  //    result can be:
  //    - value: version of the released lease
  //    - false: action failed (version mismatch)
  //    - undefined: storage error
  that.release = function( version, cb ) {
    get( function( lease ) {
      if( !lease ) {
        cb( lease );
      } else {
        var lease_str = release_lease_json( lease );
        lease_cache.clear();
        qs.update( lease_key, lease_str, version, cb );
      }
    });
    
  };
  
  
  // Return a string of the current lease state
  that.toString = function() {
    return util.inspect( lease_cache.get() );
  };
  
  that.toJSON = function() { 
    return JSON.stringify( lease_cache.get() );
  };
    
  // Shutdown the QS manually as needed
  that.close = function() { qs.close(); };
  
  return that;
};

module.exports = QuorumLease;