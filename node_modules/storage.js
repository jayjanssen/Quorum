// Copyright (c) 2011 Yahoo! Inc. All rights reserved. Licensed under the BSD
// License. See accompanying LICENSE file or
// http://www.opensource.org/licenses/BSD-3-Clause for the specific language
// governing permissions and limitations under the
// License.

// A simple layer on top of the zookeeper API to mask the zkpr client complexities
var log = require( 'logger' )( 'Storage', 'TRACE');

var ZK = require ('zookeeper').ZooKeeper;
var util = require( 'util' );
var path = require( 'path' );
var async = require( 'async' );
var os = require( 'os' );

var QuorumStorage = (function() {
  var that = {};

  // connection manager object is responsible for maintaining the connection to zk
  var connection_manager = (function() {    
    var cm = {};  
  
    // Start connection immediately (global for all instances)
    var zk_trying = false;
    var zkclass;
    var zk;

    // tries to make a connection (if one isn't already being attempted), waits for timeout
    // or connected event, whichever comes first and returns handle or undefined accordingly
    var zk_connect = function( callback ) {
      var timeoutId;
      var am_trying = false;
      
      if( zk_trying !== true ) {
        log.info( "trying connecting" );
        zk_trying = true;
        am_trying = true;
        zkclass = new ZK();
        // connect to zk
        zkclass.init( {connect:'localhost:2181', timeout: 500, 
          data_as_buffer: false, debug_level:ZK.ZOO_LOG_LEVEL_WARNING} );  
          
        zkclass.once( ZK.on_closed, function() { 
          log.info( "zk on_closed event" );
          zk = undefined;
        });
      } else {
        log.info( "waiting for someone else to connect" );
      }

      // what to do if we get a connection
      var on_connected = function( zkk ) {
        log.info( 'zk session established, id=' + zkk.client_id );
        
        if( am_trying ) {
          zk_trying = false;
          zk = zkk;          
        }
      
        // unregister the timeout event
        clearTimeout( timeoutId );
        
        callback( zkk );
      };
      
      // What to do if we get a timeout
      var on_timeout = function() {
        if( zk === undefined ) {
          log.error( "Couldn't get connection" );
          
          if( am_trying ) {
            zk_trying = false;
            zk = undefined;
          }
          
          // unregister the on_connected event
          zkclass.removeListener( ZK.on_connected, on_connected );
          
          callback( undefined );
          log.debug( "timeout finished" );
        }
      };
      
      // Register the callbacks
      zkclass.once( ZK.on_connected, on_connected );    
      timeoutId = setTimeout( on_timeout, 1000);
    }; 
    
    // Wrapper for all client-dependent functions, verifies connection is present
    // before executing callback
    cm.get_handle = function( callback ) {
      if( zk === undefined ) {
        // try to connect
        log.trace( "no connection, trying");
        zk_connect( callback );   
      } else {
        log.trace( "Already got connection");
        callback( zk );
      }
    };
    
    cm.disconnect = function() {
      log.trace( "Invalidating handle" );
      if( zk !== undefined ) {
        zk.close();
        zk = undefined;
      }
    };
    
    // Handle misc ZK errors (esp ZK.ZCONNECTIONLOSS)
    cm.handle_zk_error = function( rc, error, func, args ) {
      if( rc === ZK.ZOK ) {
        return;
      }
      log.warn( "Zookeeper error: " + error + " (" + rc + ")" );
      if( rc !== ZK.ZCLOSING ) { // ZK is not already closing
        log.warn( " disconnecting..." );
        zk.close();        
      }
      zk = undefined;
      
      // auto reconnect
      if( rc === ZK.ZCLOSING ) {
        var arr = Array.prototype.slice.call( args );
        func.apply( that, arr );
      } 
    };
        
    return cm;
  }());
  
  // Perform a ZK operation
  // - fetch the connection handle
  // - retry on failure once
  // - handle server errors automatically
  // Args:
  // - zkfunc = the zookeeper method to call
  // - args = the arguments to pass to zookeeper
  // - callback to the function in this class
  // - orig_callback = the callback to the calling function
  // - counter = don't pass in, this tracks how many times the 
  var run_zk;
  run_zk = function( zkfunc, args, callback, orig_callback, counter ) {
    log.debug( "run_zk: " + zkfunc + ", counter: " + counter );
    if( counter === undefined ) {
      counter = 0;
    } else {
      counter += 1;
    }
    connection_manager.get_handle( function( zk ) {
      if( zk === undefined ) {
        if( counter < 1 ) {
          run_zk( zkfunc, args, callback, orig_callback, counter );
        } else {
          orig_callback( undefined );
        }
      } else {
        var myargs = args.slice();
        myargs.push( function( rc ) {
          var result_args = Array.prototype.slice.call( arguments );
          // log.debug( "Results: " + util.inspect( result_args) );
          if( rc === ZK.ZCLOSING ) {

            // retry 
            if( counter < 1 ) {
              run_zk( zkfunc, args, callback, orig_callback, counter );
            } else {
              orig_callback( undefined );
            }
          } else {
            // expected result
            callback.apply( undefined, result_args );
          }
        });
        
        // console.log( "Calling zk.%s( %s )", zkfunc, myargs.toString() );
        zk[zkfunc].apply( zk, myargs );    
        
      }
    });
  };  


  // Get the requested key.  Callback called with results
  // callback( data, version ).  Possible values for data:
  // - undefined: if there was a Zkpr error
  // - false: if the node simply doesn't exist
  // - value: contents of the node 
  // - version: version of the node (only if data is not falsey)
  that.get = function( key, callback ) {
    log.trace( "Getting: " + key );
    
    run_zk( 'a_get', [key, undefined ], function( rc, error, stat, data ) {
      if( rc === ZK.ZOK ) {
        callback( data, stat.version );
      } else if( rc === ZK.ZNONODE ) {
        callback( false );
      }
    }, callback );
  };

  // Create the given key -> value.  Will recursively create parents of key
  // as necessary.
  // Args: callback( data, version )
  // callback( data, version ).  Possible values for data:
  // - undefined: if there was a Zkpr error
  // - false: if the node already exists
  // - value: contents of the node 
  // - version: version of the node (only if data is not falsey)
  that.create = function create( key, value, callback ) {
    log.debug( "Create: " + key );
    
    run_zk( 'a_create', [key, value, undefined], function( rc, error, path ) {
      log.trace( "Create on " + key + " error: " + error );
      if( rc === ZK.ZNONODE ) {
        // Need to create parent nodes first
        var parent_key = require('path').normalize( key + "/..");
        log.trace( "Creating parent: " +  parent_key );
        that.create( parent_key, undefined, function( data, version ) {
          if( version === undefined ) {
            callback( undefined );              
          } else {
            // Parent nodes created (or already exists), now retry creating key
            that.create( key, value, callback );
          }
        });  
      } else if( rc === ZK.ZOK ) {
        // Good create.  We will assume:
        // - the stored data matches what we asked it to store
        // - all newly created nodes have a version of 0
        callback( value, 0 );
        // race condition in here, hence our assumptions above...
        // run_zk( 'a_get', [path, undefined ], function( rc, error, stat, data ) {
        //  callback( data, stat.version ); 
        // }, callback );
      } else if( rc === ZK.ZNODEEXISTS ) {
        callback( false );
      }
    }, callback );
  };


  // Update an existing version of key with a new value
  // Args: key, new value, version, callback
  // version: version identifier from a previous get or create
  // callback( version ) Possible values for version:
  // - undefined: if there was a Zkpr error
  // - false: if the node version doesn't match
  // - version: version of the node
  that.update = function( key, new_val, version, callback ) {
    log.debug( 'Update: ' + key );
    
    run_zk( 'a_set', [ key, new_val, version ], function( rc, error, stat ) {
      log.debug( "Update on " + key + ": " + rc + ", " + error );
      
      if( rc === ZK.ZBADVERSION ) {
        log.warn( "Couldn't update " + key + ", bad version (" + version + ")" );
        callback( false );
      } else if( rc === ZK.ZOK ) {
        log.debug( "updated, new version: " + stat.version );
        callback( stat.version );  
      }      
    }, callback );
  };

  // Delete the given version of the given key
  // Args: key, version, callback( result )
  // Possible values for result:
  // - undefined: if there was some other Zkpr error
  // - false: if the node couldn't be removed (version mismatch)
  // - true: if the node was removed 
  that.remove = function( key, version, callback ) {
    log.debug( "Remove: " + key );
    
    run_zk( 'a_delete_', [key, version ], function( rc, error ) {
      if( rc === ZK.ZOK ) {
        callback( true );
      } else if( rc === ZK.ZNONODE ) {
        callback( false );
      }
    }, callback );
  };
  
  // Get the requested key's children
  // Args: key, callback( children )
  // Possible values for children:
  // - undefined: if there was some Zkpr error
  // - array: the array of children names (could be empty)
  that.get_children = function( key, callback ) {
    log.debug( "Get Children: " + key );
    
    run_zk( 'a_get_children', [key, undefined ], function( rc, error, children ) {
      if( rc === ZK.ZOK ) {
        callback( children );
      }
    }, callback );
  };
  
  // Get all requested key's children, recursively
  // Args: key, callback( children )
  // Possible values for children:
  // - undefined: if there was some Zkpr error
  // - array: the array of children names (could be empty)    
  // ---- maybe this should replace get_children above
  that.get_all_children = function( key, callback ) {
    log.debug( "Get all children" );
    run_zk( 'a_get_children', [key, undefined], function( rc, error, children ) {
       if( rc === ZK.ZOK ) {
          if( children.length > 0 ) {
            async.concat( children, function( child, cb ) {
              var real_child = key.replace( /\/$/, ''); // strip ending slash
              real_child += "/" + child;
              log.trace( real_child + " finding children" );
              that.get_all_children( real_child, function( sub_children ) {
                cb( null, sub_children );
              });
            }, function( err, results ) { 
              var i,
                  answer = [ key ];
              for( i = 0; i < results.length; i += 1 ) {
                answer.push( results[i] );
              }
              log.trace( "Children of " + key + ": " + util.inspect( answer ));
              callback( answer );
            });            
          } else {
            callback( [ key ] );
          }
        }      
    });  
  };  
  
  // Close the ZK connection
  that.close = function() {
    log.info( "Closing" );
    connection_manager.disconnect();
  };
  
  // Get all registered processes
  that.get_registered_processes = function( callback ) {
    that.get_children( register_base_path, function( procs ) {
      if( procs === undefined ) {
       callback( undefined );
      } else {
        // Form an ad-hoc process object with relevant process metadata for each process
        async.map( procs, function( proc, cb ) {
          log.debug( "Getting data for " + proc );
          
          run_zk( 'a_get', [register_base_path + '/' + proc, undefined], function(rc, error, stat, data) {            
            if( rc === ZK.ZOK ) {              
              var proc_obj = {
                'id': proc,
                'since': stat.ctime
              };
      
              var proc_parse = /^(.*)_(\d+)$/.exec( proc );
              if( proc_parse !== null ) {
                proc_obj.host = proc_parse[1];
                proc_obj.pid = proc_parse[2];
              }
      
              cb( null, proc_obj );
            } else if( rc === ZK.ZNONODE ) {
              cb(); // nothing, must have went away
            }
          }, function() { cb( true ); }); // error from run_zk
        }, function( err, results ) {
          if( err ) {
            callback( undefined );
          } else {
            var results_obj = results.reduce( function( obj, proc ) {
              obj[proc.id] = proc;
              delete proc.id;
              return obj;
            }, {} );
            callback( results_obj );            
          }
        });
      }
    });    
  };
  
  // Is this process registered?
  that.is_registered = function( callback ) {
    that.get( register_path, callback );
  };

  // Function that establishes an EPHEMERAL node identifying this server in storage
  var register_base_path = '/quorum_node';
  var register_path = register_base_path + '/' + os.hostname() + '_' + process.pid;
  
  that.register_process = function() {
    that.create( register_base_path, undefined, function( result ) {
      if( result || result === false ) { // node created, or already exists
        run_zk( 'a_create', [register_path, '', ZK.ZOO_EPHEMERAL], function(rc, error, path) {
          if( rc === ZK.ZOK ) {
            log.info( "Registered with zoookeeper: " + path );
          } else if( rc === ZK.ZNODEEXISTS ) {  
            // ZNODEEXISTS
            log.info( "Still registered with zookeeper" );
          }
        }, function() {
          log.info( "Couldn't register with zookeeper" );
        }); 
      } else {
        log.warn( "Could not register process!" );
      }
    });
  };
  
  // set of functions dealing with server in/out of rotation
  var rotation_path = '/quorum_rotation/' + os.hostname();
  
  that.in_rotation = function( callback ) {
    that.get( rotation_path, callback );
  };
  
  that.put_in_rotation = function( callback ) {
    that.create( rotation_path, true, function( result ) {
      callback( result );
    });
  };
  
  that.take_out_of_rotation = function( callback ) {
    that.get( rotation_path, function( result, version ) {
      if( result ) {
        that.remove( rotation_path, version, function( result ) {
          callback( result );
        });        
      } else {
        callback( result );
      }
    });
  };
  
  
  return that;
}());

module.exports = QuorumStorage;