// Copyright (c) 2011 Yahoo! Inc. All rights reserved. Licensed under the BSD
// License. See accompanying LICENSE file or
// http://www.opensource.org/licenses/BSD-3-Clause for the specific language
// governing permissions and limitations under the
// License.

// Module to handle all REST v1 methods.   
var log = require( 'logger' )( 'RestV1', 'DEBUG');
var util = require( 'util' );
var async = require( 'async' );
var QuorumLease = require( './lease' );
var qs = require("./storage");

var RestV1 = function() {
  var that = {};

  qs.register_process(); // register this process with storage
  // re-register every minute, in case we weren't connected
  var register_interval = setInterval( qs.register_process, 60000 ); 
  
  that.handle = function( req, response ) {
    // Check if the req is for a reserved function
    if( req.is_health_check ) {
      // Health check (GET only)
      if( req.method === 'GET' || req.method === 'HEAD' ) {
        get_healthcheck( req, response );        
      } else {
        response( 501, undefined, 'Not implemented ' + req.method );
      } 
    } else if( req.key === '/list' ) {
      // List keys (GET only)
      if( req.method === 'GET' ) {
        get_list( req, response );        
      } else {
        response( 501, undefined, 'Not implemented ' + req.method );
      } 
    } else {
      // must just be a regular lease request
      switch( req.method ) {
      case 'GET':
        get( req, response );
        break;
      case 'POST':
        post( req, response );
        break;
      case 'PUT':
        put( req, response );
        break;
      case 'DELETE':
        delete_( req, response );
        break;
      case 'HEAD':
        head( req, response );
        break;
      default:
        response( 501, undefined, 'Not implemented ' + req.method );
      }      
    }
  };
  
  // Determines the proper content-type to return (including precedence logic)
  var get_content_type = function( accept_header ) {
    //, doesn't determine "best" type, just the first one it finds
    if( /application\/xml/.test( accept_header )) {
      return 'application/xml';
    } else if( /text\/html/.test( accept_header )) {
      return 'text/html';
    } else if( /application\/json/.test( accept_header )) {
      return 'application/json';
    } else if( /text\/plain/.test( accept_header )) {
      return 'text/plain';
    } else {
      return null;
    }
  };
  
  // Create a headers and content based on a lease
  var get_lease_response = function( req, lease, callback ) {    
    var type = get_content_type( req.headers.accept );
    
    lease.fetch( function( obj ) {
      var output;
      var headers = lease.toHTTPHeaders();
      headers['Content-Type'] = type;      

      if( type === 'application/xml') {
        output = '<?xml version="1.0"?>\n';
        output += '<?xml-stylesheet type="text/xsl" href="/static/lease.xsl"?>\n' ;
        output += lease.toXML();
      } else if( type === 'text/html' ) {
        output = "<html><head><meta http-equiv='refresh' content='30'></head><body>"
        output += lease.toHTML();        
        output += "</body></html>";
      } else if( type === 'application/json' ) {
        output = lease.toJSON();        
      } else if( type === 'text/plain' ) {
        output = lease.toString();        
      } else {
        delete headers['Content-Type'];
        output = obj.client_object;
      }      

      log.trace( "Headers: " + util.inspect( headers ));
      log.trace( "Content: " + util.inspect( output ));
      
      callback( headers, output );
    });    
  };
  
  
  // Check if a lease exists and is acquired
  var get = function( req, response ) {
    var lease = QuorumLease( req.pathname );
    lease.is_valid( function( bool ) {
      var code = bool ? 200 : 404;
      get_lease_response( req, lease, function( headers, content ) {
        if( content === '' ) { //???
          content = "Lease not found";
        }
        log.trace( "GET LEASE: " + lease.toString() );
        if( req.method === 'HEAD' ) {
          response( code, headers, null );
        } else {
          response( code, headers, content );          
        }
      });
    });        
  };
  
  // Check if a lease is acquired (like get but with no object)
  var head = get;

  
  // Acquire a lease (only unowned)
  var post = function( req, response ) {
    var lease = QuorumLease( req.pathname);
    
    async.parallel({
      is_owner: function( cb ) { 
        lease.is_owner( req.client_id, function( result ) {
          cb( null, result );
        }); 
      },
      is_valid: function( cb ) { 
        lease.is_valid( function( result ) {
          cb( null, result );
        }); 
      },
      version: function( cb ) {
        lease.get_version( function( version ) {
          cb( null, version ? version : null );
        });
      },
      auth_ok: function( cb ) { req.auth_request( cb ); },
      content: function( cb ) { req.load_client_data( cb ); }
    }, function( err, results ) {
      if( err ) { // must be an httperror
        get_lease_response( req, lease, function( headers, content ) {
          response( err.code, headers, err.message );
        });    
      } else if( results.is_owner ) {
        get_lease_response( req, lease, function( headers, content ) {
          response( 405, headers, 'You Already Own the Lease, use PUT to renew' );
        });
      } else if( results.is_valid ) {
        get_lease_response( req, lease, function( headers, content ) {
          response( 409, headers, 'Version Conflict' );
        });
      } else {
        // Proceed
        
        lease.acquire( req.client_id, req.ttl, results.content, results.version, function( results ) {
          if( results === undefined ) {
            response( 503, {}, 'Storage Error' );
          } else if( results === false ) {
            get_lease_response( req, lease, function( headers, content ) {
              response( 409, headers, 'Version conflict' );
            });
          } else {
            get_lease_response( req, lease, function( headers, content ) {
              response( 201, headers, 'Lease Acquired' );
            });
          }
        });
      }
    });
  };
  
  // Renew a lease (must own said lease)
  var put = function( req, response ) {
    if( req.storage_version === undefined ) {
      // No client version?
      response( 409, {}, 'Missing version header' );
      return;
    }
    
    var lease = QuorumLease( req.pathname );
    
    async.parallel({
      is_owner: function( cb ) { 
        lease.is_owner( req.client_id, function( result ) {
          cb( null, result );
        }); 
      },
      is_valid: function( cb ) { 
        lease.is_valid( function( result ) {
          cb( null, result );
        }); 
      },
      auth_ok: function( cb ) { req.auth_request( cb ); },
      content: function( cb ) { req.load_client_data( cb ); }
    }, function( err, results ) {
      if( err ) { // must be an httperror
        get_lease_response( req, lease, function( headers, content ) {
          response( err.code, headers, err.message );
        });    
      } else if( !results.is_owner ) {
        get_lease_response( req, lease, function( headers, content ) {
          response( 403, headers, 'You do not own the lease' );
        });
      } else {
        // Proceed
        
        lease.renew( req.storage_version, results.content, function( results ) {
          if( results === undefined ) {
            response( 503, {}, 'Storage Error' );
          } else if( results === false ) {
            get_lease_response( req, lease, function( headers, content ) {
              response( 409, headers, 'Version conflict' );
            });
          } else {
            get_lease_response( req, lease, function( headers, content ) {
              response( 202, headers, 'Lease Renewed' );
            });
          }
        });
      }
    });
  };
  
  // Release a lease (must own lease)
  var delete_ = function( req, response ) {
    if( req.storage_version === undefined ) {
      // No client version?
      response( 409, {}, 'Missing version header' );
      return;
    }

    var lease = QuorumLease( req.pathname );
    
    async.parallel({
      is_owner: function( cb ) { 
        lease.is_owner( req.client_id, function( result ) {
          cb( null, result );
        }); 
      },
      is_valid: function( cb ) { 
        lease.is_valid( function( result ) {
          cb( null, result );
        }); 
      },
      auth_ok: function( cb ) { req.auth_request( cb ); }
    }, function( err, results ) {
      if( err ) { // must be an httperror
        get_lease_response( req, lease, function( headers, content ) {
          response( err.code, headers, err.message );
        });      
      } else if( !results.is_owner ) {
        get_lease_response( req, lease, function( headers, content ) {
          response( 403, headers, 'You do not own the lease' );
        });
      } else if( !results.is_valid ) {
        get_lease_response( req, lease, function( headers, content ) {
          response( 404, headers, 'Lease Free' );
        });
      } else {
        // Proceed
        lease.release( req.storage_version, function( results ) {
          if( results === undefined ) {
            response( 503, {}, 'Storage Error' );
          } else if( results === false ) {
            get_lease_response( req, lease, function( headers, content ) {
              response( 409, headers, 'Version conflict' );
            });
          } else {
            get_lease_response( req, lease, function( headers, content ) {
              response( 204, headers, 'Lease Released' );
            });
          }
        });
      }
    });
  };
  
  
  // get a complete list of all leases in this namespace
  var get_list = function( req, response ) {        
    var type = get_content_type( req.headers.accept );
    // scan the storage layer
    qs.get_all_children( req.lease_prefix, function( children ) {      
      // Filter out all children who aren't actually leases
      async.map( children, function( child, cb ) {
        var lease = QuorumLease( child );
        lease.is_lease( function( result ) {
          if( result ) {
            lease.fetch( function() { cb( null, lease ); });
          } else {
            cb( null, null );
          }
        });
      }, function( err, results ) {
        log.trace( util.inspect( results ));
        
        // remove null array values
        var clean_results = results.filter( function( item ) { return item !== null; });
        
        if( type === 'text/plain' ) {
          
        } else {
          response( 200, { 'Content-Type': 'application/json' }, JSON.stringify( clean_results ));                    
        }

      });
    });
  };
  
  // handle health check requests
  // --- maybe want to verify we can register here... only servers who can write to zkpr should be alive
  var get_healthcheck = function( req, response ) {
    qs.in_rotation( function( in_rotation ) {
      if( in_rotation ) {
        response( 200, {}, "Server in rotation" );
      } else {
        response( 404, {}, "Server not in rotation\n" + util.inspect( in_rotation ));
      }
    });
  };

  // Shutdown the QS manually as needed
  that.close = function() {
    qs.close(); 
    clearInterval( register_interval );
  };
  
  return that;
};

module.exports = RestV1(); // export this as a library
