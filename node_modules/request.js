var log = require( 'logger' )( 'Request', 'DEBUG');
var util = require( 'util' );
var url = require('url');
var os = require( 'os' );
var auth = require( './auth' );
var HttpError = require( './httperror' );

// Create a quorum request object from a http.ServerRequest (req)
var QuorumRequest = function( req ) {
  var request = req;

  var that = {};
  
  // Validate the method is supported before spending more time
  var valid_methods = { 'GET':1 , 'POST':1, 'PUT':1, 'DELETE':1, 'HEAD':1 };
  if( valid_methods[req.method] === undefined ) {
    throw HttpError( 501, 'Not implemented ' + req.method );
  }
  that.method = req.method;
  
  // Store client requested content-type
  that.accept = req.accept;
  
  // parse the request url
  var u = url.parse( req.url, false );
    
  // Don't accept query strings, reject the request if there are any
  if( u.query !== undefined ) {
    throw HttpError( 400, 'Bad request ' + u.pathname ); // ???
  }
  that.pathname = u.pathname;
  
  // Parse the pathname for a valid path that we handle:
  
  if( u.pathname === '/v1/health' ) {
    that.is_health_check = true;
  } else if( /^\/v1\/lease.xsl$/.test( u.pathname )) {
    that.is_xsl = true;
  } else {
    // Parse the pathname to extract the namespace, the primitive, and the lease ID.
    var path_parse = /^\/v1\/(.+)\/(lease)(\/.+)$/.exec( u.pathname );
    if( path_parse === null ) {
      throw HttpError( 400, 'Bad parse');
    }
  
    // Now scrub throughly
    that.namespace = path_parse[1];
    that.lease_prefix = '/v1/' + path_parse[1] + '/lease'; //     
    that.key = path_parse[3];                          // as-is
  }
  
  // Store incoming headers in case the auth function needs them
  that.headers = req.headers;
  that.remoteAddress = req.connection.remoteAddress;
    
  // Determine the ID of the client
  that.client_id = ( req.headers['x-quorum-client-id'] !== undefined ) ? 
    req.headers['x-quorum-client-id'] : req.connection.remoteAddress;
    
  // Determine the requested ttl
  that.ttl = ( req.headers['x-quorum-lease-length'] !== undefined ) ?
    req.headers['x-quorum-lease-length'] : 60; // default of 60 seconds

  // Determine the version  (undefined if header not set)
  that.storage_version = req.headers['x-quorum-lease-version'];
  
  // Only used by unit tests, overrides http body load
  that.test_data = req.test_data;

  log.debug( "Request headers: " + util.inspect( req.headers ));
  
  // function that will asynchronously fetch any data the client sent
  // and validate its length. Callback will be called after it is fetched
  // cb( data )
  // Possible conditions:
  //  - data ok
  //  - no data given
  //  - data too large
  that.load_client_data = function( cb ) {
    if( that.test_data !== undefined ) { // used by unit tests only
      cb( null, that.test_data );
      return;
    }
    var data = '';
    
    // Listen for data events and add it to our data string
    req.addListener( 'data', function( chunk ) { data += chunk; });
    
    req.addListener( 'end', function() {      
      // Validate data length
      if( data.length > 4096 ) {
        cb( HttpError( 413, 'Request Entity Too Large' ), null );
      } else {
        // send the data out
        cb( null, unescape( data ));              
      }
    });
    
    // Client request was closed before we got all the data
    req.addListener( 'close', function( err ) {
      log.debug( "Got error listening to 'close': " + err );
      if( err === 'timeout' ) {
        cb( HttpError( 408, 'Request timeout' ));
      } else {
        cb( HttpError( 400, 'Bad request -- error uploading file' ));
      }
    });
  };
  
  // function to authenticate and authorize the request 
  // This function is defined in the auth.js file, and should be replaced with
  // a working authentication/authorization function
  that.auth_request = auth;
    
  return that;
};

module.exports = QuorumRequest;